[ { "title": "Creating a Character Controller with C++ (Part Two)", "url": "/posts/cpp-character-controller-2/", "categories": "University, Devblog", "tags": "university, c++, unreal engine", "date": "2023-04-18 00:00:00 +0100", "snippet": "After planning the character controller, it was time to implement it. The implementation so far has been very involved, so I will only cover the high-level points required to get to a minimally via...", "content": "After planning the character controller, it was time to implement it. The implementation so far has been very involved, so I will only cover the high-level points required to get to a minimally viable character controller.ArchitectureTo support the extensible nature of this character controller, it needs to be architectured in much of a ‚Äúdistributed‚Äù manner. This means there is a central Simulation class that manages and orchestrates any number of MoveTypes.This choice of architecture is highly beneficial because it leaves so much room for future expansion. All move types are entirely decoupled from one another, so they can be changed and added trivially without impacting other move types. Keeping move types in distinctly separate classes also simplifies maintenance and documentation because of the clear separation of concerns.Visual example of this choice of architecture. Highlights the clear separation of concerns and flow of data.Simulation ClassAt the core of the controller is the Simulation. This class orchestrates and manages the lifecycle of all MoveTypes. It works like this: The Simulation stores most state relevant to the running of the character‚Äôs physics sim. This includes: Simulation constants (walk speed, run speed, jump height, etc.) SimulationState, a struct that contains the runtime state of the Simulation, such as the current MoveType, and the velocity and position of the character. The Simulation exposes several utility methods for use by move types. For example, the Sweep implementation is defined in the Simulation as a public method. Our Sweep method abstracts away the gritty details of Unreal Engine‚Äôs Sweep API, giving the developer a straightforward interface for performing Sweep tests in the world. Other methods, such as ProjectVelocity, are also defined here, which we‚Äôll explore later. The Simulation exposes methods for transitioning to a new MoveType. It handles cleaning up the old MoveType and ensuring the new one runs in the same frame (if that was specified as an option).Finally, the Simulation exposes a public method for ticking the sim forward. This method is very lightweight because it only calls the Tick method in the active MoveType and reconciles and changes.Most of the work in the Simulation class happens in the utility methods, which can be relatively complex. However, in concept, the Simulation class only orchestrates the MoveType classes.MoveType ClassesThe MoveType classes are the backbone of our character controller and can be best thought of as state machines that define how the character can move. Each MoveType class is unique and encapsulates the behaviours and rules for a specific movement type, such as walking, running, jumping, or crouching. By keeping these behaviours separate, we can create a clean, maintainable codebase where each movement type can evolve independently from the others.MoveType classes are designed with extensibility in mind. Each class is independent and agnostic of the others, so developers can easily add new movement types or modify existing ones without worrying about unexpected side effects. For instance, if you wanted to add a new ‚Äúgliding‚Äù move type, you could simply create a new MoveType subclass that encapsulates the gliding behaviour and then register it with the Simulation class. This approach makes the character controller highly flexible and adaptable to various game designs and character movements.Implementing the Physics SimulationAs already discussed in the previous blog entry, this character controller is built on the concept of sweep testing. Please refer to the previous entry for an explanation of what sweep testing is and how it is performed.The Simulation class exposes a Sweep utility method that abstracts away the details of Unreal Engine‚Äôs built-in sweeping API. This utility method removes all the boilerplate required to sweep in Unreal Engine, creating a vastly simplified API for developers to consume.std::tuple&lt;bool, FHitResult&gt; ACharacterController::Sweep(const FVector StartPosition, const FVector EndPosition) const{ FCollisionQueryParams Params = FCollisionQueryParams(); Params.bTraceComplex = true; FHitResult SweepResult; bool Hit = GetWorld()-&gt;SweepSingleByChannel( SweepResult, StartPosition, EndPosition, SweepRotation, ECC_PhysicsBody, SweepShape, Params ); return {Hit, SweepResult};}For a visual aid, here is a diagram showcasing how a Sweep works:Demonstration of a sweep test, a simple example of moving a box throught the world until it hits a wall.All other physics routines are built on top of this method. For example, we detect if the player is standing on the ground by sweeping down from a position a very tiny amount. They are considered to be grounded if the sweep hits something.Visual example of how GoundCheck queries work.ProjectVelocityAnother core component of the physics routine is the ProjectVelocity method. The implementation of this routine is based heavily on that of Quake and Chickynoid, as discussed in the previous blog entry.ProjectVelocity projects the character through the world based on some velocity over a certain period of time (given by DeltaTime). This builds on top of sweeps by handling velocity deflections as the player moves along surfaces. ProjectVelocity is the magic that allows players to slide along walls!The idea looks like this:Demonstration of ProjectVelocity. This diagram is recreated from one the author of Chickynoid used to teach my the idea behind this technique (thank you ‚ù§Ô∏è).In this diagram, the player is projected by some significant velocity value and deflected along three different walls. This behaviour of sliding along walls is achieved through a combination of sweeps and handling of the resulting collision normals.std::tuple&lt;FVector, FVector, bool&gt; ACharacterController::ProjectVelocity( FVector StartPosition, FVector StartVelocity, float DeltaTime) const { FVector MovePos = StartPosition; FVector MoveVel = StartVelocity; bool HitSomething = false; TSet&lt;uint32&gt; HitObjects; float TimeLeft = DeltaTime; for (int i = 0; i &lt; 4; ++i) { if (MoveVel.Length() &lt; 0.001f) { break; // Done } if (MoveVel.GetSafeNormal().Dot(StartVelocity.GetSafeNormal()) &lt; 0.0f) { // We projected back in the opposite direction from where we started MoveVel = FVector(0, 0, 0); break; } // We only operate on a scaled down version of velocity auto [_, Result] = Sweep(MovePos, MovePos + (MoveVel * TimeLeft)); // Update our position if (Result.Time &gt; 0.0f) { MovePos = Result.TraceEnd; } // See if we swept the whole way if (Result.Time == 1.0f) { break; } // We'd have broken here if we didn't hit something HitSomething = true; // Hit! TimeLeft -= (TimeLeft * Result.Time); const uint32 HitId = Result.HitObjectHandle.GetInstanceUID(); if (HitObjects.Contains(HitId) == false) { HitObjects.Add(HitId); // Deflect the velocity and keep going MoveVel = FMathUtils::ClipVelocity(MoveVel, Result.Normal, 1.0); } else { // We hit the same object twice, push off it a bit MovePos += Result.Normal; MoveVel += Result.Normal; break; } } return {MovePos, MoveVel, HitSomething};}This code looks rather complex, but here‚Äôs a deep dive into how it works:Whenever the character moves and potentially collides with something, ProjectVelocity calls the Sweep method. This method tests the trajectory of the character from its current position to its expected position after the given time step, considering the current velocity. If a collision is detected, the Sweep method returns an FHitResult struct with a Normal vector. This Normal is a unit vector perpendicular to the surface with which the character collided.When ProjectVelocity receives this Normal, it uses it to deflect the character‚Äôs velocity, allowing the character to ‚Äúslide‚Äù along the surface instead of stopping upon collision. This is achieved by the ClipVelocity function, which modifies the character‚Äôs velocity based on the collision normal.So, if the character moved directly towards a wall and collided with it, the normal would be directed away from it, causing the character to stop. But if the character collided with the wall at an angle, the normal would be somewhat sideways, causing the character‚Äôs velocity to be deflected sideways as well. This is what allows the character to slide along walls instead of stopping.The process is repeated up to three times within a single call to ProjectVelocity, allowing multiple deflections. However, this choice of deflection count is not arbitrary. It is directly referenced from Quake III and is based on the geometric principle that it takes three planes intersecting to form a concavity that would fully catch and stop a ray. In other words, in the most complex case, the character would need to deflect off of three surfaces to navigate a corner. Despite this, the loop will usually exit after the first deflection.This is how the character can quickly slide along multiple surfaces, as illustrated in the diagram. Each deflection represents a potential change in direction, allowing the character to navigate complex environments smoothly.Keep in mind that the actual physics behind this behaviour is a bit more complex, including how the character‚Äôs speed is affected by these deflections, but this gives a general idea of how ProjectVelocity allows characters to slide along walls. A lot of credit goes to the Quake III and Chickynoid source codes as a reference to help implement this, as the math was rather complex.RetrospectiveI learnt a lot throughout this project! The controller fulfilled the majority of the requirements initially laid out. As a group, we re-implemented this controller in Unity as we changed the engine part way through our group project (that‚Äôs worth a whole other blog post). Having the opportunity to do this again with C# allowed me to fix many of the mistakes I made in this C++ version, but again, that‚Äôs for another blog entry.This controller has one big, glaring issue: it‚Äôs incompatible with Unreal Engine networking. I should have had more due diligence initially when investigating how networking would play out in this scenario. Still, I ultimately needed to use Unreal‚Äôs built-in character framework to network the character because it was simply too much work to do ourselves. If we hadn‚Äôt moved to Unity (for unrelated reasons), I would have invested the time to refactor the controller to extend off Unreal‚Äôs built-in character tools.Despite the unfortunate problem of the controller being unable to meet our networking goal, I learnt heaps from this project. As already mentioned, this was my first time ever using C++ and Unreal Engine in any non-trivial capacity, and I got to grips with C++ incredibly quickly. I suspect this is thanks to my experience with other systems languages like Rust and my years working in game engines like Roblox.On the bright side, I got to re-purpose this character controller for another solo assignment ‚Äì so all was not lost! The assignment I ultimately used this project for was a great fit, and being able to re-purpose it saved me a lot of time." }, { "title": "Creating a Character Controller with C++ (Part One)", "url": "/posts/cpp-character-controller-1/", "categories": "University, Devblog", "tags": "university, c++, unreal engine", "date": "2023-04-12 00:00:00 +0100", "snippet": "Over the past month or so, as part of a larger group assignment, I used C++ and Unreal Engine in a real-world project for the first time. The group assignment was to create a networked dodgeball ga...", "content": "Over the past month or so, as part of a larger group assignment, I used C++ and Unreal Engine in a real-world project for the first time. The group assignment was to create a networked dodgeball game, and my role was the character controller and networking.Being a university assignment, this was the perfect opportunity to experiment with technology I had never used before. I have long been fascinated with the inner workings of character controllers in video games, and I used the opportunity this assignment presented to create my own character controller from scratch, using C++ and Unreal Engine.PlanningBefore implementing the character controller, all components must be planned as appropriate. This group project is relatively short-term, with much more to do than just the character controller. As such, there is no time to go back and redo things if we implement them wrong.Character MovementOur group planning process isn‚Äôt too relevant to this blog post, so I‚Äôll summarize by saying we were targeting a Quake or Titanfall-like moveset. That is, very fast-paced movement; momentum is everything, wall running, wall jumping, vaulting, and sliding.If we had a video to summarize the perfect character movement we were aiming to achieve, then this would be it:Whilst that character movement looks (and largely is) very complex and intricate, it can be broken down into distinct movement types that can all be implemented independently with much lower complexity. There are two movement types which are absolutely essential for a minimum viable product (MVP) of our dodgeball game: Grounded: The most obvious type of movement. This movement type supports the player moving along the ground. The speed they are moving (walking v.s. sprinting) is largely irrelevant to the movement type; it‚Äôs all about traversing ground geometry. Airborne: The other most obvious movement type. This movement type supports the player moving when not in contact with any ground geometry.Supporting those two movement types is the absolute priority because the game cannot function without them. However, once our MVP is complete, we can start to explore the implementation of other types of movement: Sliding: This move type allows the player to slide along the ground with little control over their direction once the slide starts. The slide enables the player to move with a speed boost at the expense of control. The character must already be grounded to initiate a slide. Wall running: This move type allows the player to move in one direction along a wall. The player will be automatically dismounted when their forward velocity is too low or they jump (in which case they will be pushed off the wall with some forward velocity). Wall runs can be chained by jumping from wall to wall in succession. Vaulting: This move type allows players to clear obstacles in front of them if they are low enough (such as window frames or small boxes). It‚Äôs crucial that vaults are fast and can be chained with other movement types to maintain momentum.We will unlikely implement all of these different movement types by the time this assignment has to be submitted, but we planned for them and left room for their implementation. There is a reasonable period between when all assignments are due and the Graduate Showcase, which is when I plan to polish up our group project ready to be showcased there.ImplementationBefore implementing the character controller, I planned how I would actually go about doing so. A character controller can be a large and complex project, so I wanted to ensure I got this right.This assignment was an opportunity for learning, so I knew I wanted to build the controller from scratch. Whilst making it out of the building blocks Unreal Engine provides would have been significantly faster, that would have provided less opportunity to learn how a character controller truly works under the hood. As such, I decided to implement the entire controller from scratch, using a bespoke physics routine based on the implementation within Quake III. The advantage of referencing Quake III is that the source code is available online, which I can use as a guide when necessary.Additionally, I took learnings from a previous character controller that I had some limited contributions to called Chickynoid. Chickynoid is also based on Quake and is a server-authoritative character controller for Roblox. Chickynoid is based loosely on Quake and was also a great source of learning for this project.Detecting CollisionsSweep testing is the foundation of Quake III‚Äôs character controller and is how it detects collisions with world geometry. The principle behind a sweep test is that instead of checking for an intersection between an object and the environment at a single point in time (which can lead to tunnelling issues where an object moves so fast that it passes through another object between frames), the game checks for intersections over the interval of time that corresponds to a single frame of movement.This is done by essentially ‚Äúsweeping‚Äù the character‚Äôs shape (usually represented as a simplified geometric shape like a sphere or a box) along the path they would take during that frame and checking if this swept shape intersects with any of the environment geometry. If an intersection is detected, the game can then respond appropriately.Demonstration of a sweep test, a simple example of moving a box throught the world until it hits a wall.Thankfully, I don‚Äôt need to re-implement sweep tests myself because Unreal Engine already has an equivalent API built into the engine. As much as I‚Äôm using this as a learning opportunity, re-implementing an entire physics pipeline in such a short timeframe is too unrealistic. The SweepSingleByChannel API is capable of sweeping a physics shape through the world and reporting any collisions it encounters.Movement TypesAs already explored, the character controller can be broken down into a distinct set of movement types (from here on out, we‚Äôll refer to these as ‚Äúmove types‚Äù or MoveType in C++).We need a way to represent move types in C++ that allows us to create as many move types as required without coupling each move type to one another. I have a strong background in the Rust programming language, and in Rust, this would be represented perfectly by using traits, which allows you to define shared behaviour in a structured manner. Take this example:// Both no-ops for the sake of example here.struct Simulation;struct Command;trait MoveType { fn name() -&gt; String; /// Ticks this move type. Tick takes a mutable reference to the character /// simulation (i.e. it can change simulation state) and an immutable /// reference to the command that tick. A command contains the player's /// input and the delta time since the previous tick. fn tick(&amp;self, simulation: &amp;mut Simulation, command: &amp;Command) -&gt; ();}struct MoveTypeWalking;impl MoveType for MoveTypeWalking { fn name() -&gt; String { \"MoveTypeWalking\".into() } fn tick(&amp;self, _simulation: &amp;mut Simulation, _command: &amp;Command) { // Do walking simulation stuff // ... }}// For the sake of example, we also implemented `MoveType` for `MoveTypeFlying`.struct MoveTypeFlying;/// The tick method takes a reference to any move type, and also to a simulation/// and command, the same as above.fn tick&lt;T: MoveType&gt;( move_type: &amp;T, simulation: &amp;mut Simulation, command: &amp;Command) { println!(\"Ticking simulation...\"); move_type.tick(simulation, command);}In this code example, we define a MoveType trait, which allows us to implement as many move types as desired and accept any unique implementation as an argument to the tick function.This concept can also be expressed in C++ in two different ways. The first is by using abstract base classes. Abstract base classes in C++ allow for polymorphic behaviour, similar to how traits are used in Rust. However, there are some differences. In C++, abstract base classes can have data members (fields), while Rust traits cannot. On the other hand, Rust traits can have default method implementations, which C++ abstract base classes cannot. Here‚Äôs an example:#include &lt;string&gt;#include &lt;iostream&gt;// Both no-ops for the sake of example here.struct Simulation {};struct Command {};class MoveType {public: virtual std::string name() const = 0; virtual void tick(Simulation&amp; simulation, const Command&amp; command) const = 0;};class MoveTypeWalking : public MoveType {public: std::string name() const override { return \"MoveTypeWalking\"; } void tick(Simulation&amp; simulation, const Command&amp; command) const override { // Do walking simulation stuff // ... }};class MoveTypeFlying : public MoveType {public: std::string name() const override { return \"MoveTypeFlying\"; } void tick(Simulation&amp; simulation, const Command&amp; command) const override { // Do flying simulation stuff // ... }};// The tick function takes a pointer to any move type, and also to a simulation// and command, the same as above.void tick(const MoveType* move_type, Simulation&amp; simulation, const Command&amp; command) { std::cout &lt;&lt; \"Ticking simulation...\" &lt;&lt; std::endl; move_type-&gt;tick(simulation, command);}Starting with C++20, C++ introduced concepts, which are more similar to Rust traits. Concepts define a set of requirements (such as functions that must be implemented) that a type must satisfy. Here‚Äôs a simple example:#include &lt;string&gt;#include &lt;iostream&gt;// Both no-ops for the sake of example here.struct Simulation {};struct Command {};template&lt;typename T&gt;concept MoveType = requires(T t, Simulation&amp; simulation, const Command&amp; command) { { T::name() } -&gt; std::same_as&lt;std::string&gt;; { t.tick(simulation, command) } -&gt; std::same_as&lt;void&gt;;};struct MoveTypeWalking { static std::string name() { return \"MoveTypeWalking\"; } void tick(Simulation&amp; simulation, const Command&amp; command) const { // Do walking simulation stuff // ... }};struct MoveTypeFlying { static std::string name() { return \"MoveTypeFlying\"; } void tick(Simulation&amp; simulation, const Command&amp; command) const { // Do flying simulation stuff // ... }};template&lt;MoveType T&gt;void tick(T&amp; move_type, Simulation&amp; simulation, const Command&amp; command) { std::cout &lt;&lt; \"Ticking simulation...\" &lt;&lt; std::endl; move_type.tick(simulation, command);}For my implementation, I‚Äôll be going with abstract base classes. I chose this option because C++ 20 still has patchy support in Unreal Engine, and it‚Äôs unclear if I can currently use C++ concepts with the compiler toolchains that UE supports. Additionally, abstract base classes have a better online knowledge base surrounding them, which will likely make solving issues related to them significantly more straightforward.ConclusionThis entry‚Äôs purpose was to outline the planning of my C++ character controller. In the next blog entry, I will cover how I implemented the controller in C++ and where I ultimately ended up with its implementation. I have a clear vision of how to implement this controller, and I have outlined the most important parts in this entry." }, { "title": "Springs for Animation in Unity", "url": "/posts/unity-springs/", "categories": "University, Devblog", "tags": "university, c#, unity", "date": "2023-03-24 00:00:00 +0000", "snippet": "I come from a Roblox and web background, where Springs see widespread use in all facets of animation. However, this tool seems somewhat less recognized outside of these spaces, especially in the br...", "content": "I come from a Roblox and web background, where Springs see widespread use in all facets of animation. However, this tool seems somewhat less recognized outside of these spaces, especially in the broader game development scene. This blog post aims to shed light on the concept of Springs, their usage, and their benefits in game development, along with demonstrating how I‚Äôve integrated them into my own Unity projects.What are Springs?In the context of video games, a Spring is a mathematical model used to simulate and animate natural, smooth, and dynamic motion. Instead of fixed durations and curves (as with traditional animation), Springs use physical properties like mass and tension to enable fluid and natural movement.The advantage of Springs is that they simulate natural motion. Unlike traditional tweens and easings, which depend on fixed durations and curves, a Spring is a continuous motion that constantly moves to a target point. This constant fluid motion allows you to have a continuously changing target without breaking the fluidity of the animation.Additionally, springs are incredibly adaptable and versatile, making them well-suited for complex animations and interactions. Because their behaviour is determined by dynamic parameters, they can be adjusted on the fly to create various effects. This contrasts traditional animations that must be pre-calculated and cannot easily change once running without breaking fluidity.Unity Spring ImplementationHere is an example Spring implementation in Unity C#. This code is based on a Spring implementation used widely in Roblox, which can be found here.This specific implementation only supports Vector3s, but extending it to support other datatypes should be trivial.Here‚Äôs an example implementation of my Spring class, where we move a gameobject to the mouse position in the world every frame. Hopefully, this illustrates how Springs can capture fluid and natural motion with continuously changing values.class MoveToMouse : MonoBehaviour{ // Adjust speed and damper as needed public float speed = 5f; public float damper = 0.5f; private Spring _spring; private void Start() { _spring = new Spring(transform.position); _spring.Speed = speed; _spring.Damper = damper; } private void Update() { var ray = Camera.main.ScreenPointToRay(Input.mousePosition); if (Physics.Raycast(ray, out var hit)) { // Update spring target with mouse world position. The spring will move // to the current target in a fluid motion every frame. _spring.Target = hit.point; } // Position is computed lazily every time it is fetched, there is no need for // us to pass any deltaTime. transform.position = _spring.Position; }}Real-World ExampleNote: This section was added in May 2023 after completing a university assignment artefact.As already explored, Springs are great for modelling continuously changing fluid motion. As such, they are a perfect fit for first-person games that need to animate objects the character is holding, and this is the exact use case I had when creating a dodgeball game.As the video demonstrates, the dodgeball on-screen continuously reacts to the character‚Äôs motion with natural and realistic results. This result is achieved entirely with multiple Springs that have been layered together.In this specific case, four Springs were used: SwaySpring: Impulsed by two things: Horizontal and vertical changes in camera angle and; Sudden changes in vertical velocity (i.e. falling from a height and landing on the ground). WalkingSpring: Target is a sine wave whose amplitude changes based on the current horizontal speed of the character. ChargeSpring: Pulls the dodgeball backwards based on the current charge of the throw during each frame. ThrowSpring: Position is set behind the camera every time the ball is thrown, causing the ball to instantly disappear and quickly return to the frame for a realistic throw effect.These Springs are layered by adding their positions together during each frame and using the result to place the dodgeball in the world. Overall, these layered Springs create a realistic and fluid motion that would be extremely difficult to model without. This entire system was programmed in less than 120 lines of code and uses no external animations." }, { "title": "Rust and Bevy Engine: One-Button GameJam (Part Three)", "url": "/posts/one-button-jam-3/", "categories": "University, Devblog", "tags": "university, gamejam, rust", "date": "2023-02-14 00:00:00 +0000", "snippet": "This is the final entry for my One-Button GameJam series of blog posts, and we‚Äôll be covering the game‚Äôs core mechanic - golf balls! Everything from physics to sound.PhysicsIf I were to remake this...", "content": "This is the final entry for my One-Button GameJam series of blog posts, and we‚Äôll be covering the game‚Äôs core mechanic - golf balls! Everything from physics to sound.PhysicsIf I were to remake this game, with more time than two weeks, I would probably create a bespoke physics controller for the golf balls. At the time, the Bevy Engine physics scene was relatively young, and the most popular (only) physics engine integration, Rapier, had several bugs and lacked several features that came to hurt our little golf game later.However, I only had two weeks and had to use an off-the-shelf solution. So, enter:RapierRapier is a ‚ÄúFast 2D and 3D physics engine for the Rust programming language‚Äù. While the library is certainly pleasant to work with, I didn‚Äôt have any choice in picking it because it‚Äôs the only physics engine with an open-source Bevy integration. Writing integrations for any other physics engine would take too much time, so this is what I had to use.However, my lack of choice isn‚Äôt necessarily a bad thing. Rapier works, and it works really well with Bevy. The integration with Bevy (bevy_rapier) is first-party and well-maintained. The API is simple to use and is well-documented. For example, here is how to add collisions to a Bevy mesh:// Executed on startup, responsible for spawning in our map.let scene_handle = asset_server.load(\"test_map.glb#Scene0\");commands .spawn_bundle(SceneBundle { scene: scene_handle.clone(), ..default() }) .insert(Name::from(\"Map\")) .insert(AsyncSceneCollider { handle: scene_handle, // `TriMesh` gives us the most accurate collisions, at the cost of // physics complexity. shape: Some(ComputedColliderShape::TriMesh), named_shapes: HashMap::default(), })Simple enough! AsyncSceneCollider from bevy_rapier lets us add a high-fidelity TriMesh collision shape to all meshes in our scene. The collision shape is generated in a seperate thread behind the scenes and then applied to the scene when ready.Ball ControllerAt the core of our game is the golf ball controller, a system that handles launching the ball in response to some player input. Thanks to our use of an off-the-shelf physics engine, the controller is relatively simple and consists primarily of our input handling for launching the ball.Controller demonstration, showcasing the charge, launch, and respawn behaviorAs you can see in the video, we chose to give players accurate control over the power of their golf ball shots. This contrasts with many existing golf games, where the shot is based on a timer, and players must try hitting the ball at the perfect time.Based on feedback we received at the end of the GameJam, many people were receptive to our take on the charging mechanism. Its simple nature allows players to take accurate shots without having to perfectly time their mouse release. Despite the simple nature, some said this method of control felt far more enjoyable than existing golf games.Charge MechanismAt its core, the charge mechanism is straightforward in how it works. Here is what it boils down to: On mouse click, set charging to true and charge_power to 0. On mouse release, set charging to false. For each frame, increment charge_power by our mouse y delta if charging is true.Then, we can launch the ball forward on mouse release if charge_power is above some threshold. A stripped-down version of the code for this looks like this:// We should launch the ball if we were charging last frame and we're not// this frame.let should_launch = charge_state.charging_last_frame &amp;&amp; !command.charge;if should_launch { // Launch the ball! // Convert the forward vector of our camera into a flat vector, removing // the Y component. Then normalize it, so the length equals 1. let forward = (camera.forward() * Vec3::new(1.0, 0.0, 1.0)).normalize(); // Charge ratio is a number between 0 and 1 that describes how much charge // to apply to the launch. ball_velocity.linvel += forward * charge_state.charge_ratio * LAUNCH_FORCE_MULTIPLIER;}AudioLike everything else in our little golf game, audio could get much more sophisticated than it currently is, and there‚Äôs little to talk about here. We sourced appropriately licensed sourced audio from various websites and included them in our project as .ogg files. We chose to use .ogg files because of their smaller file sizes than alternatives like .mp4. .ogg is an open-source format and uses a modern compression technique called Vorbis, which maintains higher audio quality with less storage.Smaller file sizes were crucial for our use case because we wanted to embed our game on the web, and large files take considerable time to load. In the end, each audio file averaged 20kb in size.By the time we finished the game, we had multiple audio variations for the following:Club hits for when the ball is launched by the player. 3 variations, cycled between at random. Audio volume is based on how hard the ball is launched.Wall hits for when the ball makes hard contact with another surface. 5 variations, cycled between at random. Audio volume is based on ball velocity when it hits a surface.Physics BugsLooping back to the start of this post, I stated Rapier had several drawbacks that would come back to hurt us later. I wasn‚Äôt kidding!Ball Following Collision Mesh LinesRapier‚Äôs collision backend, parry, has trouble handling flat triangle collision meshes. As demonstrated in the video below, the ball is heavily influenced by the lines of a collision mesh. This bug causes the ball to stray off course. This is seemingly out of nowhere to a user if they don‚Äôt enable wireframes.Collision bug demonstration, showcasing the ball following the collision lines of a msBall Getting Stuck in BarriersWe had a bug that plagued us from the start, and we never found the cause of it. In certain situations, the golf ball would collide with a surface and become ‚Äústuck‚Äù, violently glitching back and forth every frame. I spoke with the maintainer of Rapier, who could not offer any solution. The most likely culprit we came to was that the meshes used (from Kenney) were malformed in some way, causing the physics engine to incorrectly place the ball.Regardless, the bug was clearly an issue with the physics engine we chose, and we, unfortunately, didn‚Äôt have the time to fix it there. This is what the bug looked like:Demonstration of the above bug. The camera doesn‚Äôt break in this video, for your sake.Certainly not ideal to finish with! In addition to the visual glitch, this also caused the game audio to break, producing a loud hit sound every frame.RetrospectiveThis was the first game jam of my university course, and despite our game not having the best graphics, or the breaking bugs, it went well. Not only was it an opportunity to experiment with new tech, to finally use an engine I‚Äôve wanted to for a long time, but it was also an opportunity to network with the people on my course for the first time.I probably wouldn‚Äôt change much if I did the jam again today. Bevy has already improved substantially since it took place, several release versions ahead of when the game jam took place. Using the lessons I‚Äôve learnt during the jam and after, I would probably take the time to implement my own physics controller for golf balls. That, or I would create bindings for another off-the-shelf engine, such as PhsX or Bullet.Regardless, I am pleased with how the game jam ended and what we produced. It was clearly a learning experiment, and that‚Äôs okay." }, { "title": "Rust and Bevy Engine: One-Button GameJam (Part Two)", "url": "/posts/one-button-jam-2/", "categories": "University, Devblog", "tags": "university, gamejam, rust", "date": "2023-01-26 00:00:00 +0000", "snippet": "Given that we only had two weeks to complete this game jam, our group‚Äôs concept had to be simple to execute. After exploring various ideas, we ultimately chose a minigolf-style game that used only ...", "content": "Given that we only had two weeks to complete this game jam, our group‚Äôs concept had to be simple to execute. After exploring various ideas, we ultimately chose a minigolf-style game that used only the mouse as our one button.Considering this is a programming blog, I will not delve into details about the game design. However, this is what the control scheme looked like:Mouse Movement = Pan CameraPress Left Click = Enable ChargingRelease Left Click = Release ChargingMove Y Movement = Change Charge PowerAs you can see, this is not technically single-input. However, it is one-button (left click)! Technicalities üòåImplementationNow, onto the fun stuff! As mentioned above, this game was implemented with Bevy and the Rust programming language. In this blog post, I will cover the high-level system design decisions and how they could have been implemented differently.CommandsAt the core of this game are commands. A command is generated at the start of every frame and describes the actions the player wants to take based on their input. Commands can then be queried in other systems that run later in the frame.struct Command { camera_zoom: f32, mouse_delta: Vec2, charge: bool, release_charge: bool, toggle_camera_lock: bool,}/// This code is very Bevy-specific, but an Action is essentially just an input, using the Leafwing Input Manager library.////// See https://github.com/Leafwing-Studios/leafwing-input-manager for more info.fn drive_command_gen( action_query: Query&lt;&amp;ActionState&lt;Action&gt;, With&lt;LocalPlayer&gt;&gt;, mut command_query: Query&lt;&amp;mut Command, With&lt;LocalPlayer&gt;&gt;,) { let action_state = action_query.single(); let mut old_command = command_query.single_mut(); let delta = match action_state.axis_pair(Action::MouseDelta) { Some(delta) =&gt; Vec2::new(delta.x(), delta.y()), None =&gt; Vec2::ZERO, }; // Update the old command to match new data old_command.camera_zoom = action_state.clamped_value(Action::CameraZoom); old_command.mouse_delta = delta; old_command.charge = action_state.pressed(Action::Charge); old_command.toggle_camera_lock = action_state.pressed(Action::ToggleCameraLock);}It is not easy to improve upon this system. Commands decouple gameplay systems from processing raw player input and provide an appropriate level of abstraction for player actions. The advantage of this decoupling is that gameplay systems are unaffected if input mappings change (which they probably will!). Processing keycodes and other input methods is done in one function, making later maintenance significantly more manageable.Camera ControllerAnother core component of any game is its camera controller, and our little golf game is no different! Given our short timeframe for this jam, I opted to use an open-source camera manipulation library called Dolly, which abstracts away much of the math and quaternion logic that comes with handling cameras.The camera system builds off of commands, utilising mouse_delta to drive camera rotation around the golf ball. In addition, it uses the command structs camera_zoom to drive the zoom in/out logic.Zooming the camera in and out took much tuning to get right. In addition to adjusting the camera‚Äôs distance to the golf ball, the camera‚Äôs vertical height is also adjusted based on how far the camera is zoomed out. This effect is implemented with various easings, allowing players to view their surroundings more intuitively.Camera controller demonstration, showcasing panning and zooming in/out behaviorThanks to the use of Dolly, the camera implementation remained relatively straightforward. With some of the query boilerplate omitted, this is what the camera system looks like:fn drive_camera( q0: Query&lt;(&amp;GlobalTransform, &amp;LocalCharacter)&gt;, q1: Query&lt;&amp;Command, With&lt;LocalPlayer&gt;&gt;, mut q2: Query&lt;(&amp;mut Rig, &amp;mut CameraState)&gt;, mut q3: Query&lt;&amp;mut Projection, With&lt;CurrentCamera&gt;&gt;, mut windows: ResMut&lt;Windows&gt;,) { if let Ok((ball_transform, character)) = q0.get_single() { let command = q1.single(); // SAFETY: Commands will always be generating if we have a character let (mut rig, mut camera_state) = q2.single_mut(); let mut projection = q3.single_mut(); // Set the camera position to the golf ball's position let ball_translation = ball_transform.translation(); rig.driver_mut::&lt;Position&gt;().position = ball_translation + (Vec3::Y * 0.5); // Zoom the camera in and out let new_zoom = (camera_state.zoom - (command.camera_zoom * CAMERA_ZOOM_SENSITIVITY)).clamp(0.0, 1.0); // Persist the zoom in the state for future frames to access camera_state.zoom = new_zoom; // Ease the horizontal offset along a curve, mapping the 0-1 value to the min and max horizontal offsets let horizontal_offset = map_01( ease_out_quad(new_zoom), MIN_CAMERA_Z_OFFSET, MAX_CAMERA_Z_OFFSET, ); // Ease the vertical offset along a curve, mapping the 0-1 value to the min and max vertical offsets let vertical_offset = map_01( ease_in_out_cubic(new_zoom), MIN_CAMERA_Y_OFFSET, MAX_CAMERA_Y_OFFSET, ); // Apply the offsets let arm = rig.driver_mut::&lt;Arm&gt;(); arm.offset = Vec3::new(0.0, vertical_offset, horizontal_offset); // Update the FOV of the camera, based on whether or not it is moving // TODO: Add easing to camera FOV if let Projection::Perspective(projection) = projection.deref_mut() { projection.fov = if character.should_allow_control { CAMERA_FOV_STILL } else { CAMERA_FOV_MOVING } } // Rotate the camera around the golf ball based on mouse delta if !command.charge &amp;&amp; camera_state.camera_locked { rig.driver_mut::&lt;YawPitch&gt;().rotate_yaw_pitch( -CAMERA_MOVE_SENSITIVITY * command.mouse_delta.x, -CAMERA_MOVE_SENSITIVITY * command.mouse_delta.y, ); } // A debug key can pressed to give mouse control back if command.toggle_camera_lock { camera_state.camera_locked = !camera_state.camera_locked; for window in windows.iter_mut() { window.set_cursor_lock_mode(camera_state.camera_locked); window.set_cursor_visibility(!camera_state.camera_locked); } } }} Part ThreeThe final part of this mini-series, Part Three, will cover the physics and ball controller implementations. We‚Äôll explore how it was implemented and how it could be improved." }, { "title": "Rust and Bevy Engine: One-Button GameJam (Part One)", "url": "/posts/one-button-jam-1/", "categories": "University, Devblog", "tags": "university, gamejam, rust", "date": "2023-01-20 00:00:00 +0000", "snippet": "A few months ago, I completed my first university game jam. Everybody was in teams of two to three, and the only rule was that the game could only use one button. Simple enough!While there was only...", "content": "A few months ago, I completed my first university game jam. Everybody was in teams of two to three, and the only rule was that the game could only use one button. Simple enough!While there was only one official rule, an inherent requirement of the game jam was that the game could be distributed as a standalone binary. Unfortunately, this meant that Roblox, an engine I am already highly proficient in, was immediately off the table.Additionally, I had already used Unity, Godot, and Unreal Engine in game projects. While these are absolutely acceptable candidates, I wanted to try something especially challenging and new.I was the only programmer on our three-person team, so I had an opportunity to play with some technology I was new to. Before this game jam, I had already been using the Rust programming language for about a year. I had also been watching the Bevy game engine project for a similar time. Having already been wanting to use Bevy in an actual project, Rust and Bevy are the options I ultimately went with.Bevy EngineBevy is a modular open-source and community-maintained game engine written in Rust. At Bevy‚Äôs core, it uses an Entity Component System (ECS), an architectural pattern primarily found in game development. ECS is still an emerging technology but has many advantages over your standard object-orientated component systems in engines like Unity and Unreal Engine.Without going into heavy detail (there are many resources online!), an ECS enables the decoupling of data and logic. In an ECS, systems (logic) have no state, and components (state) have no logic. This distinct separation presents several advantages over traditional object-orientated approaches: Improved performance : ECS architectures can safely multithread systems based on the data they mutually access. Additionally, an ECS is optimised for CPU cache hits, which is always great in hot code paths. Better organisation : ECS allows developers to organise their game objects and their behaviour in a more modular and organised way. This modularity can make it easier to work on large and complex games and can also make it easier for multiple developers to work on the same project. Reusability : Because ECS separates game objects into their individual components, developers can easily reuse components across different objects. This reusability can save time and effort and help ensure consistency across the game. Testability : Because most ECS systems operate on known pieces of state with no extra side effects, they can be executed in isolation using mock state during automated testing, making unit and integration tests trivial to implement. However, despite these advantages, there are some disadvantages to consider as well: Increased complexity : Because ECS involves organising game objects in a more modular and granular way, it can add complexity to the development process. This added complexity can make it more difficult for new developers to understand and work with the codebase and make it more challenging to debug and troubleshoot issues. Reduced flexibility : Because ECS requires a more structured and standardised approach to game object organisation, it can limit the flexibility of the game design. This reduced flexibility can make it more difficult to implement certain features or behaviours and make it harder to make changes or updates to the game. To end this post, I will refer to a now-famous GDC presentation the Overwatch team presented that covers their experience using an ECS architecture. In their own words, ECS reduces your flexibility to solve problems and puts you in a pit. However, that pit is a pit of success.Part TwoIn the next blog post, I will review the fun bits ‚Äì implementation! We‚Äôll explore how the game works behind the scenes, the decisions made, and what I learnt from using Bevy Engine for the first time." }, { "title": "PlayFab SDK V3", "url": "/posts/playfab-sdk-v3/", "categories": "Open-source", "tags": "library, luau, roblox, devlog", "date": "2022-10-10 00:00:00 +0100", "snippet": "Over the past few weeks, I have been working on a complete rewrite of my Microsoft PlayFab integration for Roblox. This rewrite brings some key new features and significant housekeeping to better s...", "content": "Over the past few weeks, I have been working on a complete rewrite of my Microsoft PlayFab integration for Roblox. This rewrite brings some key new features and significant housekeeping to better support community contributions.You can find the SDK here.Firstly, what is PlayFab?Quoted from PlayFab themselves: PlayFab is a complete backend platform for live games with managed game services, real-time analytics, and LiveOps.‚ÄúBut, Roblox already provides managed game services for me! What value does PlayFab bring?‚ÄùGood question, you probably asked! While you‚Äôll certainly use a smaller portion of their products as a Roblox developer, there are still a few that could be incredibly helpful. Just make sure to weigh the pros and cons of each service you consider and if it makes financial sense to use.PlayFab has many products available, and I encourage you to research them all at their website. However, I think by far the most useful to Roblox is matchmaking:MatchmakingPlayFab provides real-time matchmaking with support for complex constraints and rules. This is the same matchmaking infrastructure titles like Rainbow Six: Siege and Sea of Thieves run on.Whilst it‚Äôs certainly possible (and maybe even trivial) to implement simple queue-based matchmaking using Roblox MemoryStore‚Äôs, it‚Äôs difficult to apply multiple rules and constraints (such as region and skill-level) to tickets. Even more challenging is decentralising it across hundreds or thousands of running game servers ‚Äì all while keeping queue times low.PlayFab provides an out-of-the-box, proven matchmaking solution that supports multiple queues, rules and constraints, and in-depth matchmaking analytics to help optimise queue times. The engineering time saved going down this route could prove more cost-effective than rolling an in-house matchmaking solution.If you‚Äôre interested in seeing a production-ready implementation of PlayFab‚Äôs matchmaking in Roblox, check out the example/ directory in the SDK repository.Read more about PlayFab‚Äôs matchmaking here.Anyway, back to the SDK‚Ä¶Why the rewrite?In preparation for future projects I want to take on, I needed to get the SDK into a more usable state with Luau. While the SDK came bundled with type annotations for roblox-ts, it pre-dated Luau, and thus people who used it with Luau didn‚Äôt have proper access to API types or errors from the type checker. Additionally, it had the following other problems which helped to justify a complete rewrite: The SDK was big. PlayFab has thousands of individual APIs, each with its own type annotations for roblox-ts. These APIs added up to a lot of code, which has an excellent opportunity to be split up. I would need to work out how to make individual parts of the SDK opt-in before I could consider including Luau types. It‚Äôs hard to use PlayFab‚Äôs official generator and even harder to contribute to it. If I wanted to support community contributions to my PlayFab SDK, I would have to maintain my own fork of PlayFab‚Äôs official generator, which would have been much more work than it was worth. Looking at PlayFab‚Äôs official generator, it is cumbersome to navigate and even more difficult to edit or use. Codegen is driven by EJS templates, which have to be styled in a particular, hard-to-maintain way to get the desired output. Ultimately, I decided to run the generator periodically on my local machine and not bother with community contributions. I want to change that this time around.What‚Äôs changed?A few things! In addition to some general ergonomics improvements, all of the problems bought up above have also been addressed:Luau types! üéâMy biggest goal for the rewrite of the PlayFab SDK was to have static typing for the entire PlayFab API right inside Luau. I‚Äôm pleased to say that, as of V3, the request parameters and responses of every PlayFab API are available, and you‚Äôll receive type-checking errors when you do something wrong. Additionally, this SDK version no longer uses the Promise library, meaning Luau will preserve all type information on function returns.Screenshot of Luau code missing a required request parameter and the error given by the Luau type-checker.Migration to the Wally package managerWally is a new package manager for Roblox based on Cargo (for Rust) and NPM (for JavaScript) and is what the SDK needed to allow for opt-in PlayFab services. Each service is its own Wally package, and users only need to import the services they use. You can find a reference to the Wally packages and their current version on the SDK README.Depending on people‚Äôs needs and whatever direction Roblox‚Äôs open-source community moves, I may also consider alternate distribution methods down the line. Ultimately, I want to support native Studio users who may not be using Rojo (and, by extension, Wally), but I think this is better done by supporting Wally inside of Studio. It‚Äôs a great tool that everyone should have access to. (Hint at the next project?)A table of Wally packages for each PlayFab service, showing a description and version string for each. Each service links to the relevant PlayFab documentation.Included SDK generatorThis release brings a custom Rust-based code generator to create each Wally package automatically. If you‚Äôre contributing to the SDK, doing it through the generator is how.Similar to PlayFab‚Äôs official generator, this one generates code using PlayFab‚Äôs Swagger API specification. However, unlike the official generator, it does not use EJS templates. Instead, it uses Rust‚Äôs Writers (with the help of some macros) to construct Wally packages through code. This approach is nice and gives complete control over formatting, but there are definitely economic improvements to be made.See the generator/ directory for more.Finally, what‚Äôs next?While the SDK is in a much better place than it was previously, there are still some parts I want to improve and places I want this SDK to go in the future:Automatic updatesEverything is in place to support automatic updates to the repository, and I just need to find the time to write the GitHub Action to do it. Hopefully soon!Better error handlingTo put it bluntly, the error handling in this SDK kind of sucks. Error handling in Luau generally sucks, and the error handling approach from Rust has opened my eyes. I‚Äôm honestly not sure the best way to improve it in Luau, but I want to. Using pcalls sucks! Catching promises sucks!Better AccessibilityAs I mentioned earlier in the post, this SDK currently requires Wally to install and use it as intended. However, Wally is only available to those using Rojo. In one of my future projects, I want to bring Wally to studio users so they can access the benefits of a real package manager. More on this soon!More Open-Source!Open-source is great, and I want to keep creating open-source tools, libraries, and integrations for other developers. From now on, I will seriously consider releasing things to the community whenever I make something for myself. The only time this won‚Äôt happen is if it‚Äôs something I feel I can‚Äôt maintain long-term or if there is some security, business-related, or legal reason not to.Closing RemarksThis blog post is my first time writing this kind of long-form content, and I think it works rather nicely. Please give me feedback on whether this kind of content is interesting or helpful, as well as on my writing style ‚Äì if it‚Äôs too long, short, vague, or if I keep rambling on. I want to improve!" } ]
